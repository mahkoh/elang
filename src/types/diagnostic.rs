use crate::{
    types::{span::Span, store::StrId, token::TokenKind, tree::ExprKind},
    ExprId, Spanned,
};
use num_rational::BigRational;
use std::{fmt::Debug, rc::Rc, mem};

/// An error
#[derive(Debug)]
pub struct Error {
    pub(crate) span: Span,
    pub(crate) error: ErrorType,
    pub(crate) context: Vec<ErrorContext>,
}

impl Error {
    /// Creates a new error
    pub fn new(span: Span, ty: ErrorType) -> Self {
        Error {
            span,
            error: ty,
            context: vec!(),
        }
    }

    /// Returns the span of the error
    pub fn span(&self) -> Span {
        self.span
    }

    /// Returns the type of the error
    pub fn ty(&self) -> &ErrorType {
        &self.error
    }

    /// Adds context to an error
    pub fn add_context(mut self, ctx: ErrorContext) -> Self {
        self.context.push(ctx);
        self
    }

    /// Retrieves the current context of the error
    pub fn get_context(&self) -> &[ErrorContext] {
        &self.context
    }

    /// Replaces the context of the error
    pub fn set_context(&mut self, context: Vec<ErrorContext>) -> Vec<ErrorContext> {
        mem::replace(&mut self.context, context)
    }
}

#[derive(Copy, Clone, Debug)]
#[non_exhaustive]
pub enum ErrorContext {
    ParseString(u32),
    ParseUnicodeEscape(u32),
    ParseTest(u32),
    ParseSelect(u32),
    ParseParenthesized(u32),
    ParseFnHeader(u32),
    ParseFnPattern(u32),
    ParseLet(u32),
    ParseField(u32),
    ParseCond(u32),
    ParseList(u32),
    ParseMap(u32),
    ParseInherit(u32),
    EvalResolved(ExprId),
    EvalArithmetic(ExprId),
    EvalBool(ExprId),
    EvalOverlay(ExprId),
    EvalAdd(ExprId),
    EvalCond(ExprId),
    EvalStringify(ExprId),
    EvalApl(ExprId),
    EvalSelect(ExprId),
    EvalOtherExprType(ExprId, ExprKind),
    EvalFnPat(Span),
}

/// The type of an error
#[derive(Clone, Debug)]
#[non_exhaustive]
pub enum ErrorType {
    /// During parsing, the end of the input was reached unexpectedly
    UnexpectedEndOfInput,
    /// During parsing, an unexpected token was encountered
    UnexpectedToken {
        expected: TokenAlternative,
        encountered: TokenKind,
    },
    /// During parsing, a literal was encountered that is out-of-bounds for its type
    OutOfBoundsLiteral,
    /// During parsing of a number literal, a character in the range 0..=9 | a..=z | A..=Z was
    /// encountered which is not valid for the base of the literal
    InvalidDigit {
        digit: u8,
    },
    /// During parsing of a number literal with an explicit base, no digits were encountered after
    /// the base specifier
    EmptyNumberLiteral,
    /// During lexing, a byte was encountered that cannot be the start of any token
    InvalidByteForTokenStart {
        byte: u8,
    },
    /// During parsing of a unicode escape, the provided code point is empty
    MissingCodePoint,
    /// During parsing of a unicode escape, the provided code point is not valid
    InvalidCodePoint {
        code_point: u32,
    },
    /// During parsing of a string, an invalid escape code was encountered
    UnknownEscapeSequence {
        escape_sequence: u8,
    },
    /// During parsing of a `let`, a `set`, or a function header, the same identifier was declared
    /// multiple times
    DuplicateIdentifier {
        previous_declaration: Spanned<StrId>,
    },
    /// During evaluation, an unexpected expression kind was encountered
    UnexpectedExprKind {
        expected: &'static [ExprKind],
        encountered: ExprKind,
    },
    /// During string interpolation, a number to be interpolated was not an integer
    CannotStringifyNonInteger,
    /// An attempt was made to select a field from a map but the map has not such field
    MissingMapField {
        field_name: StrId,
    },
    /// An attempt was made to select index into a list but the index was out of bounds
    MissingListField {
        index: Rc<BigRational>,
    },
    /// During evaluation, an expression was encountered that must be evaluated before itself
    InfiniteRecursion {
        expr_id: ExprId,
    },
    /// During evaluation, an expression was encountered whose kind cannot be evaluated
    CannotEvaluateExpr {
        kind: ExprKind,
    },
    /// During evaluation, a division by zero was attempted
    DivideByZero,
    /// During evaluation of a function application, the argument did not contain of the fields
    /// required by the function pattern
    MissingArgument {
        missing_parameter: Spanned<StrId>,
    },
    /// The provided source code is too large to be parsed
    SpanOverflow,
    /// An assertion failed
    AssertionFailed,
    /// A custom error generated by an embedder-defined native function
    Custom {
        error: Rc<dyn std::error::Error + 'static>,
    },
    /// During parsing, a token was encountered that can only appear as a pair (e.g. `{`, `}`) but
    /// it appeared unpaired
    UnmatchedToken {
        kind: TokenKind,
    },
    /// During parsing, an unexpected byte was encountered
    UnexpectedByte {
        expected: &'static [u8],
        encountered: u8,
    }
}

/// An alternative to a token
///
/// This type is used for diagnostic purposes when, during parsing, an invalid token is
/// encountered. The value of this type indicates which kinds of tokens were valid in the
/// position.
#[derive(Copy, Clone, Debug, Eq, PartialEq)]
pub enum TokenAlternative {
    /// The end of the input
    EndOfInput,
    /// The start of an expression
    StartOfExpression,
    /// A list of tokens
    List {
        candidates: &'static [TokenKind],
    }
}
